#include <fstream>
#include <cmath>

#include "FractalCommon.h"

using Eigen::Vector3f;
using namespace std;

float radiusOfGyration(Aggregate const & aggregate, bool useFilippov) {
    /* TODO: implement */
    float buff = 0.0f;
    auto center = centerOfMass(aggregate);
    for (auto const & v : aggregate) {
        auto d = v-center;
        buff += d.dot(d);
    }
    buff /= float(aggregate.size());
    
    // Adding 1 per Filippov's formula
    if (useFilippov)
        buff += 1.0f;
    return sqrtf(buff);
}

Vector3f centerOfMass(Aggregate const & aggregate) {
    Vector3f center{0.0f, 0.0f, 0.0f};
    for (auto const & v : aggregate) {
        center += v;
    }
    return center / float(aggregate.size());
}

void loadVtk(Aggregate & aggregate, const char * path) {
    if (!aggregate.empty()) {
        cerr << "WARINING: Not empty aggregate passed to loadVtk(). Data will be overwritten" << endl;
        aggregate.clear();
    }
    
    ifstream ifs(path);
    if (!ifs.good()) {
        cerr << "ERROR: Unable to open file supplied to loadVtk()" << endl;
        exit(EXIT_FAILURE);
    }
    
    int count;
    // Buffer for unnecessary strings
    string _;
    // Read the header lines
    for (int i = 0; i < 4; i ++)
        getline(ifs, _);

    // Read the point count from the file
    ifs >> _ >> count >> _;
    
    // Pre-allocate memory
    aggregate.reserve(count);

    for (int i = 0; i < count; i ++) {
        float x, y, z;
        ifs >> x >> y >> z;

        aggregate.emplace_back(x, y, z);
    }
    ifs.close();
}

void dumpVtk(Aggregate const & aggregate, const char * path) {
    ofstream ofs(path);
    if (!ofs.good()) {
        cerr << "ERROR: Unable to create file supplied to dumpVtk()" << endl;
        exit(EXIT_FAILURE);
    }
    
    ofs << "# vtk DataFile Version 4.0" << endl;
    ofs << "Generated by libFractalCommon" << endl;
    ofs << "ASCII" << endl;
    ofs << "DATASET POLYDATA" << endl;
    ofs << "POINTS " << aggregate.size() << " FLOAT" << endl;
    
    for (auto const & v : aggregate) {
        ofs << v[0] << " " << v[1] << " " << v[2] << " ";
    }
    ofs.close();
}

ostream & operator << (ostream & os, Aggregate const & aggregate) {
    os << "AGGREGATE, N=" << aggregate.size() << endl;
    for (auto const & v : aggregate) {
        os << v[0] << " " << v[1] << " " << v[2] << endl;
    }
    os << "END AGGREGATE";   
    return os;
}
