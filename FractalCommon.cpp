// Collection of functions frequently used in fractal analysis
// Made by Egor Demidov in 2023

#include <fstream>
#include <cmath>

#include "FractalCommon.h"

using Eigen::Vector3f;
using namespace std;

template<typename T>
std::vector<T> getSubVector(std::vector<T> const & v, std::vector<int> const & indices) {
    vector<T> out;
    out.reserve(indices.size());
    for (auto i : indices)
        out.emplace_back(v[i]);
    return out;
}

// Instantiation of templates
template Aggregate getSubVector(Aggregate const & v, vector<int> const & indices);
// End instantiation of templates

float radiusOfGyration(Aggregate const & aggregate, bool useFilippov) {
    /* TODO: implement */
    float buff = 0.0f;
    auto center = centerOfMass(aggregate);
    for (auto const & v : aggregate) {
        auto d = v-center;
        buff += d.dot(d);
    }
    buff /= float(aggregate.size());
    
    // Adding 1 per Filippov's formula
    if (useFilippov)
        buff += 1.0f;
    return sqrtf(buff);
}

Vector3f centerOfMass(Aggregate const & aggregate) {
    Vector3f center{0.0f, 0.0f, 0.0f};
    for (auto const & v : aggregate) {
        center += v;
    }
    return center / float(aggregate.size());
}

void loadVtk(Aggregate & aggregate, const char * path) {
    if (!aggregate.empty()) {
        cerr << "WARINING: Not empty aggregate passed to loadVtk(). Data will be overwritten" << endl;
        aggregate.clear();
    }
    
    ifstream ifs(path);
    if (!ifs.good()) {
        cerr << "ERROR: Unable to open file supplied to loadVtk()" << endl;
        exit(EXIT_FAILURE);
    }
    
    int count;
    // Buffer for unnecessary strings
    string _;
    // Read the header lines
    for (int i = 0; i < 4; i ++)
        getline(ifs, _);

    // Read the point count from the file
    ifs >> _ >> count >> _;
    
    // Pre-allocate memory
    aggregate.reserve(count);

    for (int i = 0; i < count; i ++) {
        float x, y, z;
        ifs >> x >> y >> z;

        aggregate.emplace_back(x, y, z);
    }
    ifs.close();
}

void dumpVtk(Aggregate const & aggregate, const char * path) {
    ofstream ofs(path);
    if (!ofs.good()) {
        cerr << "ERROR: Unable to create file supplied to dumpVtk()" << endl;
        exit(EXIT_FAILURE);
    }
    
    ofs << "# vtk DataFile Version 4.0" << endl;
    ofs << "Generated by libFractalCommon" << endl;
    ofs << "ASCII" << endl;
    ofs << "DATASET POLYDATA" << endl;
    ofs << "POINTS " << aggregate.size() << " FLOAT" << endl;
    
    for (auto const & v : aggregate) {
        ofs << v[0] << " " << v[1] << " " << v[2] << " ";
    }
    ofs.close();
}

float mean(std::vector<float> const & x) {
    if (x.empty()) {
        cerr << "ERROR: Empty array supplied to mean()" << endl;
        exit(EXIT_FAILURE);
    }

    float buff = 0.0f;
    for (auto v : x)
        buff += v;
    return buff/float(x.size());
}

LinearModel linearRegression(std::vector<float> const & y, std::vector<float> const & x) {
    if (y.empty() || x.empty()) {
        cerr << "ERROR: Empty array supplied to linearRegression()" << endl;
    }
    if (y.size() != x.size()) {
        cerr << "ERROR: Arrays supplied to linearRegression() are of diffrerent sizes" << endl;
        exit(EXIT_FAILURE);
    }
    
    float y_bar = mean(y);
    float x_bar = mean(x);
    float a = 0.0f, b = 0.0f;
    for (unsigned i = 0; i < y.size(); i ++) {
        a += (x[i]-x_bar)*(y[i]-y_bar);
        b += (x[i]-x_bar)*(x[i]-x_bar);
    }
    float beta = a/b;
    float alpha = y_bar-beta*x_bar;
    return {beta, alpha};
}

ostream & operator << (ostream & os, Aggregate const & aggregate) {
    os << "AGGREGATE, N=" << aggregate.size() << endl;
    for (auto const & v : aggregate) {
        os << v[0] << " " << v[1] << " " << v[2] << endl;
    }
    os << "END AGGREGATE";   
    return os;
}
